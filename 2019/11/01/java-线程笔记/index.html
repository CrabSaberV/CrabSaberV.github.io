<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/asset/icons/crab_192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/asset/icons/crab_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/asset/icons/crab_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crabsaberv.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言线程是Java语言的一大特色，也是难点之一。在学习线程的过程中就会发现如果自己具备一些操作系统相关的进程知识，那么这一部分的学习就会相对而言变得容易些。线程其实就是一个微进程，线程是在进程中。了解进程的相关知识，某种程度上对理解线程也就没有什么障碍了。那么开始吧！ 文章较长，但请耐心阅读完，但文章主要讲解最基础知识，其中包含了许多小细节。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-线程笔记">
<meta property="og:url" content="https://crabsaberv.github.io/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="CrabSaberV is here">
<meta property="og:description" content="前言线程是Java语言的一大特色，也是难点之一。在学习线程的过程中就会发现如果自己具备一些操作系统相关的进程知识，那么这一部分的学习就会相对而言变得容易些。线程其实就是一个微进程，线程是在进程中。了解进程的相关知识，某种程度上对理解线程也就没有什么障碍了。那么开始吧！ 文章较长，但请耐心阅读完，但文章主要讲解最基础知识，其中包含了许多小细节。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://crabsaberv.github.io/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="article:published_time" content="2019-11-01T14:39:54.000Z">
<meta property="article:modified_time" content="2019-11-28T14:54:21.960Z">
<meta property="article:author" content="CrabSaberV">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://crabsaberv.github.io/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">

<link rel="canonical" href="https://crabsaberv.github.io/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java-线程笔记 | CrabSaberV is here</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CrabSaberV is here</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://crabsaberv.github.io/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CrabSaberV">
      <meta itemprop="description" content="This is my presonal blog. Here will be conplete.Let's look forward!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrabSaberV is here">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-线程笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-01 22:39:54" itemprop="dateCreated datePublished" datetime="2019-11-01T22:39:54+08:00">2019-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-28 22:54:21" itemprop="dateModified" datetime="2019-11-28T22:54:21+08:00">2019-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线程是Java语言的一大特色，也是难点之一。在学习线程的过程中就会发现如果自己具备一些操作系统相关的进程知识，那么这一部分的学习就会相对而言变得容易些。线程其实就是一个微进程，线程是在进程中。了解进程的相关知识，某种程度上对理解线程也就没有什么障碍了。那么开始吧！</p>
<p>文章较长，但请耐心阅读完，但文章主要讲解最基础知识，其中包含了许多小细节。</p>
<a id="more"></a>

<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在多任务操作系统中，运行多个进程来并发执行多个任务。同理有时我们希望提高一个进程的运行速度，或者同时处理多个代码，那么就可以使用线程来解决。每个线程就是一个独立的执行自身指令的不同的控制流。其和进程十分相似。</p>
<p>有了线程，也就有了多线程。多线程值一个程序中包含多个执行流，多线程是实现并发的一种优先手段，多线程可以做到例如：一个线程运行GUI，一个线程运行I/O等。</p>
<p>了解了线程知识那么可以做到，一个application在处理一些任务同时，可以播放音乐或动画。</p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul>
<li>进程是由代码，数据，内核状态（PCB）和一组寄存器组成，</li>
<li>线程是由表示程序运行状态的寄存器以及堆栈组成，不包含进程地址空间中的代码和数据</li>
<li>线程是计算过程中的某一个时刻的状态</li>
<li>进程结果所有成分都在内核空间中，用户程序不能直接访问</li>
<li>线程是一个用户级实体，数据驻留在用户空间中，可被用户程序直接访问</li>
</ul>
<h3 id="Java中线程模型"><a href="#Java中线程模型" class="headerlink" title="Java中线程模型"></a>Java中线程模型</h3><p>Java中的线程模型包括：</p>
<ul>
<li>一个虚拟CPU</li>
<li>该CPU执行的代码</li>
<li>代码操作的数据<br>代码与数据是独立的。数据也可以被同时访问，也就是共享资源</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p><code>java.lang</code>中的 Thread类 是多线程程序设计基础。创建线程可以通过调用Thread的构造方法实现。</p>
<p>线程中的代码和数据构成了线程体，线程体决定了线程的行为。线程体是由线程类的<code>run()</code>方法定义，线程开始执行也是先从run()开始的。</p>
<h3 id="Thread类的构造方法"><a href="#Thread类的构造方法" class="headerlink" title="Thread类的构造方法"></a>Thread类的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>group</code> —— 指明此线程所属的线程组</li>
<li><code>target</code> —— 提供线程的对象。其中<code>java.lang.Runnable</code>接口中定义了run()方法，实现此接口的类所实例化的对象可以提供线程体。（可以理解Thread是提供了线程需要的环境配置，Runnable是提供一个实例对象线程行为）</li>
<li><code>name</code> —— 线程名称。当为null时，Java会提供一个唯一的名称。</li>
</ul>
<p><em>以上的参数都是可以为 null 的。</em></p>
<p>创建一个线程有两种方法<strong>实现Runnable接口创建线程</strong>和<strong>通过继承Thread类创建线程</strong>。</p>
<h3 id="通过实现-Runnable-接口创建线程"><a href="#通过实现-Runnable-接口创建线程" class="headerlink" title="通过实现 Runnable 接口创建线程"></a>通过实现 Runnable 接口创建线程</h3><p><code>java.lang</code>中 Runnable 接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程</p>
<ol>
<li>创建一个线程类并实现 Runnable 接口，同时在<code>run()</code>中实现线程体。</li>
<li>将实现 Runnable 接口的类的实例对象作为参数，传递给 Thread 的构造方法。</li>
</ol>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数存在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThread1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Hello(<span class="string">"th1"</span>));</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Hello(<span class="string">"th2"</span>));</span><br><span class="line">		<span class="comment">// 运行线程</span></span><br><span class="line">		th1.start(); <span class="comment">// th1线程运行</span></span><br><span class="line">		th2.start(); <span class="comment">// th2线程运行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Runnable的实例类，用于提供线程体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 线程体，内部实现线程需要做的事</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello! This is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello! This is th1</span><br><span class="line">Hello! This is th2</span><br></pre></td></tr></table></figure>
<h3 id="通过继承-Thread类-创建线程"><a href="#通过继承-Thread类-创建线程" class="headerlink" title="通过继承 Thread类 创建线程"></a>通过继承 Thread类 创建线程</h3><p><code>java.lang</code>中的 Thread类 声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="title">implemets</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出Thread类本身已经实现了 Runnable 接口了,因此Thread类中存在<code>run()</code>方法。<br>创建线程步骤：</p>
<ol>
<li>创建 Thread 的子类，并重写<code>run()</code>方法实现线程体。</li>
<li>创建该子类的实例对象，也就事创建了一个线程。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数所在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatThread2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HelloE thr1 = <span class="keyword">new</span> HelloE(<span class="string">"thr1"</span>);</span><br><span class="line">		HelloE thr2 = <span class="keyword">new</span> HelloE(<span class="string">"thr2"</span>);</span><br><span class="line">		</span><br><span class="line">		thr1.start();</span><br><span class="line">		thr2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Thread的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloE</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;	</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloE</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 线程体，内部实现线程需要做的事</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello! This is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello! This is thr2</span><br><span class="line">Hello! This is thr1</span><br></pre></td></tr></table></figure>
<h3 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h3><ul>
<li>利用继承 Thread类 的创建线程方法</li>
</ul>
<ol>
<li>代码十分简单，同时可以在其中调用其他方法，比如可以在<code>run()</code>中调用线程中其他的一些方法。</li>
</ol>
<ul>
<li>利用实现 Runnable 的创建线程方法</li>
</ul>
<ol>
<li>符合面向对象的设计思想，毕竟在实现 Runnable 接口方法不会影响到 Thread类 的体系。</li>
<li>便于继承其他类，因为是实现 Runnable 的创建线程方法，因此同时继承其他类。</li>
</ol>
<p>虽然相比而言，实现 Runnable 的方法比较推荐，但是<strong>现实中还以具体情况具体分析</strong>。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>说到线程的调度，我们会联想到进程的调度。线程的调度与进程的调度类似。当多个线程运行时，也会有资源抢占，资源共享等问题，因此对于线程的调度也是十分重要的。</p>
<p>概念上线程是并发执行，但是由于计算机是单个CPU，所以在微观一时刻只有一个线程运行。在单个CPU中以某种顺序运行多个线程，就是线程的调度。</p>
<h3 id="线程优先级与调度策略"><a href="#线程优先级与调度策略" class="headerlink" title="线程优先级与调度策略"></a>线程优先级与调度策略</h3><p>Java中的线程是有优先级的。</p>
<p>Thread类中有3个线程优先级相关常量：</p>
<ul>
<li><code>MIN_PRIORITY</code> —— 最低优先级,通常为1</li>
<li><code>NORM_PRIORITY</code> —— 普通优先级，默认值为5</li>
<li><code>MAX_PRIORITY</code> —— 最高优先级，通常为10</li>
</ul>
<p>线程优先级的取值就是在<code>IN_PRIORITY</code>与<code>MAX_PRIORITY</code>之间，取值越大，优先级越高。</p>
<p>注意：</p>
<ul>
<li>新创建的线程会继承父线程的优先级，父线程就是创建线程的线程。</li>
<li>主线程具有普通优先级。</li>
<li>可以利用<code>getPriority()</code>获取线程的优先级，通过<code>setPriority(int newPriority)</code>来设置优先级</li>
<li>Java的线程调度策略是基于优先级抢占式调度（也就是A线程运行中，如果出现比A线程优先级更高的B线程，则会中断A线程，先执行B线程）</li>
<li>Java可以按照优先级设置多个线程等待池，JVM先运行高优先级的池中线程，直到高优先级池空，才考虑低优先级池（<strong>*****</strong>这里我还有点争议，还不是很清楚<strong>*****</strong>）</li>
<li>抢先机制，可能也是分时的，同等优先级池内线程轮流执行，具体由JVM而定，一般用<code>sleep()</code>来为其他线程提供运行机会。<h3 id="线程基本控制方法"><a href="#线程基本控制方法" class="headerlink" title="线程基本控制方法"></a>线程基本控制方法</h3>以下方法由 Thread类 提供</li>
</ul>
<ol>
<li><code>sleep()</code> —— 可以暂时将CPU让给其他线程，休眠时间内此线程将不再运行，时间结束后，此进程将进入（Runnable）状态。<ul>
<li><code>static void sleep(int millsecond)</code>—— 休眠时间以毫秒为单位</li>
<li><code>static void sleep(int millsecond,int nanosecond)</code>—— 休眠时间为毫秒与纳秒之和</li>
</ul>
</li>
</ol>
<p><em><strong>注意<code>sleep()</code>是个静态方法，因此直接使用 <code>Thread.sleep()</code> 即可，一般将 <code>sleep()</code> 写在需要休眠的线程的 <code>run()</code> 中，来确保此线程进入休眠阻塞，并且此此方法会抛出 <code>InterruptedException</code> 异常，因此要进行异常处理。</strong></em></p>
<ol start="2">
<li><code>yield()</code> —— 也叫做让步方法。可使与 当前线程 相同优先级的线程有机会运行（<strong>执行态 →就绪态</strong>）。如果有 其他线程 与 当前线程 有相同优先级且可运行，此方法将把调用<code>yield()</code>的线程放入可运行线程池（就绪池），允许其他线程运行。其实可以理解为<code>yeild()</code>将线程的状态由<strong>执行态</strong>变为<strong>就绪态</strong>，此线程会与其他进程共同竞争CPU资源，有可能又是自己抢到了，进程继续执行。</li>
</ol>
<p><em><strong>注意 <code>yield()</code> 是个静态方法，因此直接使用 <code>Thread.yield()</code> 即可。</strong></em></p>
<ol start="3">
<li><code>join()</code> —— 让某个线程参与运行，当前进程等待（等待过程中 此线程 处于<strong>阻塞状态</strong>）等待直到线程B结束为止，此线程 恢复到 Runable （就绪态）状态。<ul>
<li><code>join()</code>——当前线程发出调用<code>B.join()</code>,当前线程直到B执行结束再运行。</li>
<li><code>join(long millis)</code> —— 直到B线程结束后，或之后最多等待 <code>millis</code> 毫秒后，再执行</li>
<li><code>join(long millis, int nanos)</code> —— 直到B线程结束后，或最多等待<code>millis + nanos</code>（毫秒加纳秒）后再执行 </li>
</ul>
</li>
</ol>
<p><em><strong>注意：方法会抛出 <code>InterruptedException</code> 异常，因此要进行异常处理。</strong></em></p>
<ol start="4">
<li><p><code>interrupt()</code> —— 当一个线程A正在调用<code>sleep()</code>，<code>join()</code>，<code>wait()</code>等方法被阻塞时（这些方法都是使 线程 处于<strong>阻塞状态</strong>），<code>A.interrrupt()</code>将会中断A的<strong>阻塞状态</strong>，同时会抛出<code>InterrruptException</code>异常。</p>
<ul>
<li>如果线程正常在 执行 过程中使用<code>interrupt()</code>是会将线程状态的 中断标志 设置为 true ，仅此而已，程序依旧运行。</li>
<li>如果在阻塞状态，使用<code>interrupt()</code>同样使得 中断标志 为true ，同时会抛出异常，然后继续执行后序的代码（感觉就像是，强行从<code>sleep()</code>状态中 跳出来）</li>
</ul>
</li>
<li><p><code>currentThread()</code> —— 返回当前线程（线程的引用），<strong>静态方法</strong>。</p>
</li>
<li><p><code>isAlive()</code> —— 测试线程是否已启动（相当于 就绪态 和 执行态）但没有运行结束。</p>
</li>
<li><p><code>stop()</code> —— 强行使线程关闭，但是<strong>不安全，不推荐</strong>，最好自行设置一个flag，利用flag使得线程结束。其实只要<code>run()</code>执行完毕，就是线程完成退出，因此利用flag使得<code>run()</code>执行完毕。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  	<span class="keyword">public</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 当flag为false时，就是线程结束 </span></span><br><span class="line">	<span class="keyword">while</span>(flag)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>suspend()</code>和<code>resume()</code> —— 其他线程中<code>B.suspend()</code>使得 线程B 暂停执行。恢复B 在其他线程中使用<code>B.resume()</code>。 <strong>非常不推荐，容易造成死锁</strong> </p>
</li>
</ol>
<h4 id="基础方法测试项目"><a href="#基础方法测试项目" class="headerlink" title="基础方法测试项目"></a>基础方法测试项目</h4><ol>
<li><code>Thread.yield()</code>例子</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFuctionOfThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread thA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NobFirst());</span><br><span class="line">		Thread thB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NobSecond());</span><br><span class="line">		</span><br><span class="line">		thA.start();</span><br><span class="line">		thB.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// yield是个静态方法，所以这么写</span></span><br><span class="line">		Thread.yield();	<span class="comment">//让掉cpu资源，thA与thB重新争夺,也可以在AB线程内使用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NobFirst</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"This is A ------"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NobSecond</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Here is B!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">This is A ------0</span><br><span class="line">Here is B!</span><br><span class="line">This is A ------1</span><br><span class="line">This is A ------2</span><br><span class="line">This is A ------3</span><br><span class="line">This is A ------4</span><br><span class="line">This is A ------5</span><br><span class="line">This is A ------6</span><br><span class="line">This is A ------7</span><br><span class="line">This is A ------8</span><br><span class="line">This is A ------9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Thread.join()</code>例子</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFuncOfThread2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		Thread thB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NobSecond1());	</span><br><span class="line">		thB.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"This is Main ------"</span> + i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; thB.isAlive() ) &#123;</span><br><span class="line">				thB.join();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			i++;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">7</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NobSecond1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Here is B!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This is Main ------0</span><br><span class="line">This is Main ------1</span><br><span class="line">This is Main ------2</span><br><span class="line">This is Main ------3</span><br><span class="line">This is Main ------4</span><br><span class="line">This is Main ------5</span><br><span class="line">Here is B!</span><br><span class="line">Here is B!</span><br><span class="line">Here is B!</span><br><span class="line">Here is B!</span><br><span class="line">Here is B!</span><br><span class="line">Here is B!</span><br><span class="line">This is Main ------6</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>Thread.interrupt()</code>例子</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFuncOfThread3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		NobFirst2 th1 = <span class="keyword">new</span> NobFirst2();</span><br><span class="line">		th1.start();</span><br><span class="line">		</span><br><span class="line">		th1.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NobFirst2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">					</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">					System.out.println(<span class="string">"here interrupt!!!"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 持续打印中断状态</span></span><br><span class="line">			System.out.println(<span class="string">"This is A -----isInterrupt: "</span> + <span class="keyword">this</span>.isInterrupted());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">This is A -----isInterrupt: true</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at try_thread.second.NobFirst2.run(SomeFuncOfThread3.java:25)</span><br><span class="line">here interrupt!!!</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br><span class="line">This is A -----isInterrupt: false</span><br></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>多个线程并发执行，往往容易因为访问操作 共享资源 且对线程不加以限制而引起一些混乱（例如共享资源的修改，导致结果不可再现）。</p>
<p>这里简单解释一个例子：<br>前提：<br>有两个线程 A 和 B ，两线程有个共同的一个代码段是对 Stack 栈的<code>pop()</code>（出栈）操作以及之后的<code>push()</code>（压栈）操作，假若开始 Stack 中只有一个数据，线程A和B并发同时开始。</p>
<p>过程：<br>在某个时刻，A 线程对 Stack 正在<code>push()</code>操作（此时 Stack 中数据为空）。<br>可能下一刻线程 B 要对 Stack 进行<code>pop()</code>操作，但此时 Stack 中数据为空，就会产生异常。</p>
<h3 id="对象死锁以及操作"><a href="#对象死锁以及操作" class="headerlink" title="对象死锁以及操作"></a>对象死锁以及操作</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>针对以上由于共享资源而可能产生的异常，Java中对共享资源的操作采用了传统的封锁计数。（是不是感觉和 进程 的一些知识很相似）</p>
<p>临界区：一个程序的各个并发线程对同一个对象（共享资源）进行访问的代码段，称为临界区。在Java中临界区可以是一个代码块或者一个方法，使用<code>synchronized</code>关键字标识。<br>临界区的控制是通过对象锁进行的。</p>
<p>对象锁：Java中将每个由<code>synchronized(someObject){}</code>语句指定对象<code>someObject</code>设置一个对象锁。对象锁是一种排他锁，当一个线程获取对象锁以后，才拥有了对该对象的操作权，其他没有获取到对象锁的线程则无法访问操作。（线程进入临界区时，先通过<code>synchornized(someObject)</code>语句测试并获取对象锁。如果对象锁以及被使用中，那么无法获取到对象锁）</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个Stack中的pop（）方法设置对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	synchornized(<span class="keyword">this</span>)&#123;</span><br><span class="line">		...<span class="comment">//内容</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然可以对整个方法设置对象锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个Stack中的pop（）方法设置对象锁</span></span><br><span class="line"><span class="comment">// 优点很简便，但是并发中对并发效率会有所影响，虽然不是很大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> synchornized <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...<span class="comment">//内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>还是之前的例子 ：<br>前提：<br>有两个线程 A 和 B ，两线程有个共同的一个代码段是对 Stack 栈的<code>pop()</code>（出栈）操作以及之后的<code>push()</code>（压栈）操作，假若开始 Stack 中只有一个数据，线程A和B并发同时开始。</p>
<p>当<code>pop()</code>等方法有了对象锁后，则对Stack的对象设置了唯一的对象锁。<br>过程：<br>某个时刻A对 Stack 进行<code>push()</code>，此时 B 要对Stack进行<code>pop()</code>操作，但是由于对象锁被 A 使用中，B 无法获取对象锁，因此，B此时只能等待。<br>直到 A 释放了对象锁，B才能获取对象锁。</p>
<h4 id="对象锁的使用相关说明"><a href="#对象锁的使用相关说明" class="headerlink" title="对象锁的使用相关说明"></a>对象锁的使用相关说明</h4><ol>
<li><p>对象锁的返还，有以下几种情况。</p>
<ul>
<li>当<code>synchornized()</code>语句块执行完毕后。</li>
<li>当<code>synchornized()</code>语句块中出现异常</li>
<li>持有锁的线程调用<code>wait()</code>方法。此时线程将释放对象锁，线程放入对象wait pool 中，等待某个事件发生。</li>
</ul>
</li>
<li><p>共享资源所有访问必须作为临界区，使用<code>synchornized</code>关键词标记。没有标记对象锁的方法，将会绕过对象锁。</p>
</li>
<li><p>用<code>synchornized</code>保护的共享数据（也就是成员变量或者其他变量）必须是私有的。这样就要使用<code>getxxx()</code>和<code>setxxx()</code>访问数据，对这些方法设置对象锁，就是对私有变量数据进行了对象锁保护。</p>
</li>
<li><p>如果整个方法的代码块都是<code>synchornized</code>的作用域，那么可以将关键字放在方法声明中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个Stack中的pop（）方法设置对象锁</span></span><br><span class="line"><span class="comment">// 优点很简便，但是并发中对并发效率会有所影响，虽然不是很大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> synchornized <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...<span class="comment">//内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>对象锁有重入性。也就是当线程无法获取对象锁时（另一个线程正在使用此对象锁），另一个线程释放对象锁后，此线程可以再次获取对象锁。<h3 id="死锁防治"><a href="#死锁防治" class="headerlink" title="死锁防治"></a>死锁防治</h3>如果多个线程互相争夺等待对方持有的锁，在得到对方锁之前都不会释放自己持有的锁，这就容易造成线程都不能继续执行，也就是死锁。</li>
</ol>
<p>Java没有专门检测和避免死锁的机制，因此需要程序来进行控制，防止死锁。</p>
<p>一般方法为：如果多个线程访问共享数据，则要先从全局考虑定义一个获得锁的顺序，并且整个程序中都遵循这个顺序（也就是每个线程，要访问某个资源获得这个资源锁，则必须先获得上一个资源的锁）。释放锁时，按加锁的反序来释放锁。（反序释放锁，一个好处是，这样一边释放锁，另一边线程就能申请获取锁）</p>
<p><em>（类似 进程的防止死锁 ）</em></p>
<h3 id="线程间交互wait-和notify"><a href="#线程间交互wait-和notify" class="headerlink" title="线程间交互wait()和notify()"></a>线程间交互wait()和notify()</h3><p>有些时候，某个线程进入了<code>synchornized</code>块 中，但是此时 共享资源 的状态并不满足它的需要，它要等其他线程将 这个共享资源 状态改变为它所需要的状态才可以继续运行。但是由于它占有了该对象锁，这使得其他线程无法对共享数据进行访问和操作。</p>
<p>为此在Java的<code>java.lang.Object</code>包中引入<code>wait()</code>和<code>notify()</code>，来实现线程间的通讯。</p>
<h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h3><p>要说说<code>wait()</code>和 <code>notify()</code>，那就用一个简单的例子理解。</p>
<p>假设两个线程 A 和 B，它们共同访问一个共享资源X（共享资源的操作都有<code>synchornized</code>标识）。</p>
<p>A线程在访问共享资源 X（对象）的某个方法过程中需要，B来对共享源进行操作（但是此时 A 占有者对象的锁，），因此 X 对象中的这个方法此时调用<code>wait()</code>——<code>X.wait()</code>（实际情况是，<code>wait()</code>写在 X 的类的方法中，那么在那个方法中调用<code>this.wait()</code>即可），会将线程 A 放入 X 的 wait pool 中（等待池）并且释放X对象的锁。</p>
<p>此时，B 线程可能抢夺到 X 锁进而运行，当B处理完时，需要唤醒 A 时，使用<code>X.notify()</code>（同理在 X 类方法中 是使用 <code>this.notify()</code>）随机唤醒一个线程（目前只有一个 A 线程在 X 的wait pool中，因此是唤醒了 A 线程）将 A 线程移入到 lock pool 中（锁池）准备获取 X 对象锁，一旦 A 获取锁，A 即可继续运行。</p>
<p>系统中类似这种使用某种资源的行为其实是一种 生产者-消费者 的关系。<br>一般 使用某个资源的线程被称为 消费者。<br>产生或释放同类资源的线程称为 生产者。</p>
<p><a href="https://github.com/CrabSaberV/Java_Restudy_Review/blob/master/src/try_thread/thrid/SomeFuncOfThread.java" target="_blank" rel="noopener">这里有相关的<code>wait()</code>和<code>notify()</code>的Java测试代码。</a></p>
<h4 id="总结以及注意事项"><a href="#总结以及注意事项" class="headerlink" title="总结以及注意事项"></a>总结以及注意事项</h4><ul>
<li><code>wait()</code>和<code>notify()</code>就是为<code>synchornized</code>而使用，因此这两个方法最好在<code>synchorized</code>块中使用</li>
<li><code>wait()</code>和<code>notify()</code>必须由<strong>有锁的对象</strong>来调用（往往由共享资源对象 来调用此方法）</li>
<li><code>wait()</code>的调用，会将当前使用对象锁的线程 移动到 wait pool （理解为线程此时处于 等待状态）中，同时会释放锁</li>
<li><code>wait(long time)</code>中填入参数<code>time</code>（毫秒）,则线程进入等待状态，时间到了后，没有被唤醒，那么线程会继续执行后面的内容（其实就是不需要被 唤醒了，进入需要获取锁 lock pool 中）</li>
<li><code>notify()</code>的调用，会随机从 wait pool 中唤醒一个线程，将线程放入 lock pool（放入lock pool中的线程，就是需要获取此对象锁的线程）</li>
<li><code>notifyAll()</code>会唤醒所有在 wait pool 中的线程，将所有线程放入 lock pool 中</li>
</ul>
<h2 id="线程状态和生命周期"><a href="#线程状态和生命周期" class="headerlink" title="线程状态和生命周期"></a>线程状态和生命周期</h2><p>说完了这些线程基本知识，接下来我们来梳理以下线程的状态以及其生命周期。这下，会对线程每个 周期以及状态会有十分清晰的了解了。</p>
<h3 id="线程生命周期模型"><a href="#线程生命周期模型" class="headerlink" title="线程生命周期模型"></a>线程生命周期模型</h3><p>线程的生命周期和进程生命周期几乎相同。<br><img src="/2019/11/01/java-%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="1" title="线程生命周期"></p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ol>
<li><p><strong>新建状态（new）</strong></p>
<p> 也就是调用一个线程的构造方法，简单的说就是创建线程。但是创建的线程并不会马上启动，此时的线程就是处于新建状态，线程也没有获取相关资源。只能使用<code>start()</code>和<code>stop()</code>。</p>
</li>
<li><p><strong>可运行状态（Runnable）</strong></p>
<p> 新建的线程调用<code>start()</code>，其会为线程分配必要的资源，将线程中的虚拟CPU置为Runnable 状态，此线程将会由系统来调度。<br> 可运行状态其实也就是就绪状态，此时的线程并不一定获得CPU，不一定在运行。某个时刻可能多个线程处于此状态，这些线程会互相竞争CPU资源，这个通过系统根据其内部的线程调度策略来决定调度。</p>
</li>
<li><p><strong>运行状态（Running）</strong></p>
<p> 运行态是线程占有CPU并运行的状态，这时候的线程状态有3中变迁：</p>
<ol>
<li>线程正常执行结束或应用程序结束，就会进入终止状态。</li>
<li>当前线程执行了<code>yiled()</code>或者因调度策略（比如一个优先级更高的线程进入 可运行状态 ，那么这个高优先权线程会直接被调度使用CPU，当前的线程也就被抢走了CPU；也有可能使分时方式下，当前线程 时间片 结束了）会进入 可运行状态 。</li>
<li>发生以下情况进入 阻塞状态 ：</li>
</ol>
<ul>
<li>线程调用了<code>sleep()</code>或<code>join()</code>方法</li>
<li>线程调用<code>wait()</code>方法</li>
<li>线程中使用<code>synchornized</code>请求锁，但没有获得锁，进入阻塞状态。</li>
<li>线程中有输入/输出操作，也会进入阻塞状态，操作结束后，线程进入 可运行状态 。</li>
</ul>
</li>
<li><p><strong>阻塞状态（Blocked）</strong></p>
<p> 阻塞原因又有 对象锁阻塞（blocked in lock pool），等待阻塞（blocked in wait pool）和 其他阻塞（otherwise blocked）。变迁分别如下：</p>
<ul>
<li>线程调用<code>sleep()</code>和<code>join()</code>进入 其他阻塞状态。当<code>sleep()</code>的睡眠时间结束 或 者<code>join()</code>对方的线程执行完毕后或等待时间结束，就进入可运行状态</li>
<li>线程调用<code>wait()</code>进入 等待阻塞。等待阻塞 下线程如果被<code>notify()</code>或<code>notifyAll()</code>唤醒，或被<code>interrupt()</code>中断 或 等待时间结束，进入 对象锁阻塞状态</li>
<li>线程中使用<code>synchornized</code>请求对象的锁，但没有获得，进入对象锁阻塞，直到线程获取到锁，就可以进入 可运行状态</li>
</ul>
</li>
<li><p><strong>终止状态（Dead）</strong></p>
<p> 线程执行结束，没有任何方法能改变这个状态。</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这也仅仅是 线程 的皮毛知识，后续会继续更新与线程相关的一些经验。</p>
<p>线程是Java的难点，基础知识必须掌握，这样才能更加灵活去运用，才能去更近一步了解更高阶的知识。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>非常感谢这些文献：<br><em>[1]：《Java语言程序设计（第3版）》—郎波—清华大学出版社</em><br><em>[2]：Java中interrupt()方法详解附带demo  —wdfwolf3 博客 —<a href="https://www.cnblogs.com/wdfwolf3/p/7464260.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdfwolf3/p/7464260.html</a></em></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/24/java-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%AC%94%E8%AE%B0/" rel="prev" title="Java-输入/输出笔记">
      <i class="fa fa-chevron-left"></i> Java-输入/输出笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/07/String%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%A9%BA%E5%88%A4%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="next" title="String中的三种空判断的区别">
      String中的三种空判断的区别 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程概念"><span class="nav-number">2.</span> <span class="nav-text">线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与线程的区别"><span class="nav-number">2.1.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中线程模型"><span class="nav-number">2.2.</span> <span class="nav-text">Java中线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的创建"><span class="nav-number">3.</span> <span class="nav-text">线程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread类的构造方法"><span class="nav-number">3.1.</span> <span class="nav-text">Thread类的构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过实现-Runnable-接口创建线程"><span class="nav-number">3.2.</span> <span class="nav-text">通过实现 Runnable 接口创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过继承-Thread类-创建线程"><span class="nav-number">3.3.</span> <span class="nav-text">通过继承 Thread类 创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种方式比较"><span class="nav-number">3.4.</span> <span class="nav-text">两种方式比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程调度"><span class="nav-number">4.</span> <span class="nav-text">线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程优先级与调度策略"><span class="nav-number">4.1.</span> <span class="nav-text">线程优先级与调度策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程基本控制方法"><span class="nav-number">4.2.</span> <span class="nav-text">线程基本控制方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础方法测试项目"><span class="nav-number">4.2.1.</span> <span class="nav-text">基础方法测试项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">5.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象死锁以及操作"><span class="nav-number">5.1.</span> <span class="nav-text">对象死锁以及操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">5.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解"><span class="nav-number">5.1.2.</span> <span class="nav-text">理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象锁的使用相关说明"><span class="nav-number">5.1.3.</span> <span class="nav-text">对象锁的使用相关说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁防治"><span class="nav-number">5.2.</span> <span class="nav-text">死锁防治</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间交互wait-和notify"><span class="nav-number">5.3.</span> <span class="nav-text">线程间交互wait()和notify()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-和-notify"><span class="nav-number">5.4.</span> <span class="nav-text">wait() 和 notify()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结以及注意事项"><span class="nav-number">5.4.1.</span> <span class="nav-text">总结以及注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态和生命周期"><span class="nav-number">6.</span> <span class="nav-text">线程状态和生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程生命周期模型"><span class="nav-number">6.1.</span> <span class="nav-text">线程生命周期模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程状态"><span class="nav-number">6.2.</span> <span class="nav-text">线程状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">7.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">8.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CrabSaberV</p>
  <div class="site-description" itemprop="description">This is my presonal blog. Here will be conplete.Let's look forward!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CrabSaberV</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
